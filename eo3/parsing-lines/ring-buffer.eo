+alias eo3.parsing-lines.assert
+alias eo3.parsing-lines.max
+alias eo3.parsing-lines.min
+home https://github.com/yegor256/eo3-programs
+package eo3.parsing-lines
+spdx SPDX-FileCopyrightText: Copyright (c) 2022-2025 Yegor Bugayenko
+spdx SPDX-License-Identifier: MIT
+version 0.0.0

# This object is an abstraction of a "Ring Buffer" that may receive input
# from one side and be read from the other side, rolling over when the
# end of the buffer is reached.
#
# The object is immutable (as all objects in EO), but the piece of memory
# that it encapsulates (the `block` attribute) is volatile: it may change
# its content and its size too.
[block start length] > ring-buffer
  # The content of it.
  content > @

  # Create an empty buffer on top of an existing
  # memory block, which is provided as the only argument.
  # It doesn't matter how big is the memory block, here
  # we just assume that the ring buffer will use it, starting
  # from the first byte.
  [m] > empty
    ring-buffer > @
      m
      0
      0

  # Returns TRUE if there are no bytes in the buffer. This
  # doesn't mean that the size of the memory block is zero.
  # Instead, it means that there are no valuable data in the
  # memory block at the moment.
  [] > is-empty
    length.eq 0 > @

  # Returns the position of the byte where the next writing
  # must start. For example,
  # there are 10 content bytes in the buffer, the start
  # is at the 20th position, while the size
  # of the block is 25 bytes. The `cursor` would be at the 6th
  # position.
  #
  # If the buffer is full, the cursor will point to the byte
  # that contains the data! Be careful, don't write there! Instead,
  # increase the size of the `block` first.
  [] > cursor
    if. > @
      length.eq 0
      start
      mod.
        QQ.math.real
          start.plus length
        block.size

  # Returns TRUE if the tail of the buffer is ahead of its head,
  # which is a normal situation. For example, the size of the
  # buffer is 10 (the size of the memory block that it encapsulates),
  # its head is at the 8th position and the length of the content
  # is five bytes. In this situation, the `currsor` of the buffer (the
  # position of the first empty byte) would be at the 3rd byte
  # (if we start counting from zero).
  [] > is-flipped
    gt. > @
      start.plus length
      block.size

  # Return a new ring buffer, with a piece of data removed
  # from the head. The block doesn't change, just the position
  # of the internal pointers move, thus getting rid of the
  # necessary head of the text.
  [dec] > beheaded
    ring-buffer > @
      block
      mod.
        QQ.math.real
          start.plus dec
        block.size
      length.minus dec

  # Returns the content of the buffer, as a straight
  # chain of bytes. The buffer may have two pieces of data,
  # where first part is the head and the second is the
  # tail located in the opposite order inside the memory
  # block. Here, we concatenate them and return.
  [] > content
    as-bytes. > @
      if.
        is-flipped
        concat.
          block.slice
            start
            block.size.minus start
          block.slice
            0
            cursor
        block.slice start length

  # Make it large enough to fit this number of bytes. Here,
  # we return a new buffer that encapsulates the same block,
  # but resized if necessary. The block is not only being resized,
  # but the data parts it contains are moved to the right
  # locations.
  [size] > fit
    seq > @
      *
        if.
          lte.
            size
            block.size
          true
          seq
            *
              block.size > before!
              is-flipped > flipped!
              cursor > c!
              block.resized size
              if.
                flipped.as-bool
                seq
                  *
                    min > tail
                      block.size.minus before
                      c.as-number
                    block.copy 0 before tail
                    block.copy
                      tail
                      0
                      max
                        0
                        c.as-number.minus tail
                true
        ring-buffer block start length

  # Make a new ring buffer, encapsulating the same memory
  # block, but with an added tail.
  [data] > with
    seq > @
      *
        if.
          is-flipped.
            fit
              data.size.plus length
          block.write cursor data
          seq
            *
              write.
                block
                cursor
                data.slice
                  0
                  min
                    data.size
                    block.size.minus cursor
              write.
                block
                0
                data.slice
                  min
                    data.size
                    block.size.minus cursor
                  max
                    0
                    data.size.minus
                      block.size.minus cursor
        ring-buffer
          block
          start
          length.plus data.size

  # Here, we check that an empty buffer returns true
  # when being checked for emptiness.
  [] +> says-empty-is-empty
    malloc.of > @
      200
      [m]
        is-empty. > @
          ring-buffer.empty m

  # Here, we check that an empty buffer is not flipped.
  [] +> says-empty-is-not-flipped
    malloc.of > @
      33
      [m]
        not. > @
          is-flipped.
            ring-buffer.empty m

  # Here, we check that a full buffer is not yet flipped.
  [] +> says-full-buffer-is-not-flipped
    malloc.of > @
      5
      [m]
        not. > @
          is-flipped.
            with.
              ring-buffer.empty m
              "hello"

  # Here, we check that a beheaded buffer is not flipped.
  [] +> says-beheaded-buffer-is-not-flipped
    malloc.of > @
      12
      [m]
        not. > @
          is-flipped.
            beheaded.
              with.
                ring-buffer.empty m
                "hello, dude"
              3

  # Here, we check that a cursor in a full buffer points to start.
  [] +> says-cursor-in-full-buffer-points-to-start
    malloc.of > @
      9
      [m]
        assert > @
          0
          cursor.
            with.
              ring-buffer.empty m
              "some text"

  # Here, we check that a beheaded buffer has cursor pointing
  # to zero position.
  [] +> says-cursor-points-to-start-in-beheaded-buffer
    malloc.of > @
      7
      [m]
        assert > @
          0
          cursor.
            beheaded.
              with.
                ring-buffer.empty m
                "just me"
              3

  # Here, we calculate the position of the cursor of the buffer,
  # which is the place at which the next byte can be written.
  [] +> says-cursor-of-empty
    malloc.of > @
      42
      [m]
        assert > @
          0
          cursor.
            ring-buffer.empty m

  # Here, we calculate the position of the cursor of the buffer,
  # which is the place at which the next byte can be written.
  [] +> says-cursor-of-non-empty
    malloc.of > @
      42
      [m]
        assert > @
          5
          cursor.
            with.
              ring-buffer.empty m
              "hello".as-bytes

  # Here, we take the content from an empty buffer, which
  # must be an empty chain of bytes.
  [] +> builds-content-of-empty
    malloc.of > @
      17
      [m]
        assert > @
          0
          size.
            content.
              ring-buffer.empty m

  # This is a unit test for the `ring-buffer` object (to be executed
  # from the command line with the help of `eoc` command line tool).
  [] +> makes-simple-with
    malloc.of > @
      42
      [m]
        assert > @
          5
          size.
            content.
              with.
                ring-buffer.empty m
                "hello".as-bytes

  # Here, we fill up the buffer to its maximum limit and then
  # read back its content, which must be of the same size as
  # the size of the buffer.
  [] +> makes-buffer-full
    malloc.of > @
      1
      [m]
        assert > @
          48
          size.
            content.
              with.
                with.
                  with.
                    ring-buffer.empty m
                    "0123456789abcdef".as-bytes
                  "0123456789abcdef".as-bytes
                "0123456789abcdef".as-bytes

  # This is a unit test for the `ring-buffer` object (to be executed
  # from the command line with the help of `eoc` command line tool).
  [] +> makes-simple-double-with
    malloc.of > @
      42
      [m]
        assert > @
          "hello, world!"
          string
            content.
              with.
                with.
                  ring-buffer.empty m
                  "hello".as-bytes
                ", world!".as-bytes

  # This is a unit test for the `ring-buffer` object (to be executed
  # from the command line with the help of `eoc` command line tool).
  [] +> makes-with-flipping
    malloc.of > @
      12
      [m]
        assert > @
          10
          size.
            content.
              with.
                ring-buffer m 8 6
                "abcd".as-bytes

  # This is a unit test for the `ring-buffer` object (to be executed
  # from the command line with the help of `eoc` command line tool).
  [] +> makes-simple-empty-with
    malloc.of > @
      0
      [m]
        assert > @
          5
          size.
            content.
              with.
                ring-buffer.empty m
                "hello".as-bytes

  # This is a unit test for the `ring-buffer` object (to be executed
  # from the command line with the help of `eoc` command line tool).
  [] +> makes-simple-beheaded
    malloc.of > @
      42
      [m]
        assert > @
          "llo, world!"
          content.
            beheaded.
              with.
                ring-buffer.empty m
                "hello, world!".as-bytes
              2

  # Here, we make a smaller buffer ready for a large piece of data,
  # making sure it correctly moves data inside (no flipping intended).
  [] +> makes-non-flipped-buffer-fit
    malloc.of > @
      10
      [m]
        assert > @
          "one two"
          content.
            fit.
              with.
                ring-buffer.empty m
                "one two".as-bytes
              20

  # Here, we make a smaller buffer ready for a large piece of data,
  # making sure it correctly moves data inside (placing the tail
  # to the end of the head).
  [] +> makes-flipped-buffer-fit
    malloc.of > @
      10
      [m]
        assert > @
          "rt text tail"
          content.
            fit.
              with.
                beheaded.
                  with.
                    ring-buffer.empty m
                    "short text".as-bytes
                  3
                " tail"
              20

  # Here, we enlarge a flipped buffer.
  [] +> enlarges-flipped-buffer
    malloc.of > @
      9
      [m]
        assert > @
          "thingss that work"
          content.
            with.
              with.
                beheaded.
                  with.
                    ring-buffer.empty m
                    "something".as-bytes
                  4
                "ss"
              " that work"

  # Here, we fill up the buffer, then behead it, and then add more
  # content to it, thus making it flip.
  [] +> makes-flip-after-beheading
    malloc.of > @
      13
      [m]
        assert > @
          " world!ABCDEF"
          content.
            with.
              beheaded.
                with.
                  ring-buffer.empty m
                  "hello, world!".as-bytes
                6
              "ABCDEF"

  # This is a unit test for the `ring-buffer` object (to be executed
  # from the command line with the help of `eoc` command line tool).
  [] +> makes-with-and-reads
    malloc.of > @
      0
      [m]
        assert > @
          "John Malkovich"
          string
            content.
              with.
                with.
                  with.
                    ring-buffer.empty m
                    "John".as-bytes
                  " ".as-bytes
                "Malkovich".as-bytes

  # This is a unit test for the `ring-buffer` object (to be executed
  # from the command line with the help of `eoc` command line tool).
  [] +> makes-cuts-off-head
    malloc.of > @
      0
      [m]
        assert > @
          "Lebowski"
          string
            content.
              beheaded.
                with.
                  ring-buffer.empty m
                  "Jeff Lebowski".as-bytes
                5
